# this is a "script" file due to the .exs extension
# will not compile in to erlang bytecode (BEAM)
# can still be run in interactive iex session. similar to python

defmodule Math do
  def sum(a, b) do
    do_sum(a, b)
  end

  # defp defines a private function, only functions in this module can access
  defp do_sum(a, b) do
    a + b
  end

  # trailing '?' is a naming convention meaning this function returns boolean
  def zero?(0), do: true
  # matching the pattern for function zero?(0) implies the arg was an integer
  # here we use is_integer to check the type. (throws error)
  def zero?(x) when is_integer(x), do: false
end

# Kernel.inspect() turns anything in to a string
IO.puts "1 + 2 = " <> Kernel.inspect(Math.sum(1, 2))  # returns 3
IO.puts ""
# IO.puts Math.do_sum(1, 2)  # throws UndefinedFunctionError

IO.puts "zero? 0 " <> Kernel.inspect(Math.zero?(0)) # returns true
IO.puts "zero? 1 " <> Kernel.inspect(Math.zero?(1)) # returns false
IO.puts ""
# IO.puts Math.zero?([1, 2, 3]) # throws FunctionClauseError (no match)
# IO.puts Math.zero?(0.0)       # throws FunctionClauseError (no match)

# Function capturing example
# A function reference can be generated by using the name/arity notation
# e.g. Math.zero?/1 is the function name, and the number of params after /
fun_ref = &Math.zero?/1
IO.puts "fun_ref is a function? " <> Kernel.inspect(is_function(fun_ref))
# this reference behaves as an anonymous function, therefore it uses the
# fun.(params) syntax for calls. (named functions use fun(params))
IO.puts "fun_ref.(0) -> " <> Kernel.inspect(fun_ref.(0))
IO.puts ""

# this syntax can also be used for defining anonymous functions from scratch
plus_1 = &(&1 + 1)  # where &1 denotes the first argument
sum = &(&1 + &2)  # takes two args for example

IO.puts "plus_1.(3) -> " <> Kernel.inspect(plus_1.(3))
IO.puts "sum.(2, 5) -> " <> Kernel.inspect(sum.(2, 5))
